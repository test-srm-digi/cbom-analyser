"""
Demo cryptographic utilities for CBOM scanner detection.
Demonstrates Python crypto patterns covering ALL CycloneDX 1.6 asset types:
  algorithm, protocol, certificate, related-crypto-material, private-key, secret-key
"""

import hashlib
import hmac
import os
import ssl

from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding as asym_padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.kdf.scrypt import Scrypt
from cryptography.x509 import load_pem_x509_certificate
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA


# ── Hashing (algorithm) ─────────────────────────────────────────

def hash_sha256(data: bytes) -> str:
    """algorithm: SHA-256 — quantum-safe hash function."""
    return hashlib.sha256(data).hexdigest()


def hash_sha384(data: bytes) -> str:
    """algorithm: SHA-384 — quantum-safe, larger output."""
    return hashlib.sha384(data).hexdigest()


def hash_sha512(data: bytes) -> str:
    """algorithm: SHA-512 — quantum-safe, 512-bit output."""
    return hashlib.sha512(data).hexdigest()


def hash_sha1(data: bytes) -> str:
    """WARNING: SHA-1 is deprecated — collision attacks practical since 2017."""
    return hashlib.sha1(data).hexdigest()


def hash_md5(data: bytes) -> str:
    """WARNING: MD5 is cryptographically broken — never use for security."""
    return hashlib.md5(data).hexdigest()


# ── HMAC (algorithm) ────────────────────────────────────────────

def compute_hmac_sha256(key: bytes, message: bytes) -> str:
    """algorithm: HMAC-SHA256 — quantum-safe message authentication."""
    return hmac.new(key, message, hashlib.sha256).hexdigest()


def verify_hmac(key: bytes, message: bytes, expected: str) -> bool:
    """Constant-time HMAC verification to prevent timing attacks."""
    computed = hmac.new(key, message, hashlib.sha256).hexdigest()
    return hmac.compare_digest(computed, expected)


# ── Key Derivation (algorithm + related-crypto-material) ────────

def derive_key_pbkdf2(password: str, salt: bytes = None, iterations: int = 600_000) -> tuple:
    """algorithm: PBKDF2-HMAC-SHA256 — quantum-safe key derivation.
       related-crypto-material: salt (random 128-bit)."""
    if salt is None:
        salt = os.urandom(16)  # related-crypto-material: 128-bit salt
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=iterations,
    )
    derived_key = kdf.derive(password.encode())
    return derived_key, salt


def derive_key_scrypt(password: str, salt: bytes = None) -> tuple:
    """algorithm: scrypt — memory-hard key derivation, quantum-safe."""
    if salt is None:
        salt = os.urandom(16)  # related-crypto-material: salt
    kdf = Scrypt(salt=salt, length=32, n=2**14, r=8, p=1)
    derived_key = kdf.derive(password.encode())
    return derived_key, salt


def derive_key_hashlib_pbkdf2(password: str, salt: bytes = None) -> tuple:
    """algorithm: PBKDF2 via hashlib — alternative API."""
    if salt is None:
        salt = os.urandom(16)
    derived = hashlib.pbkdf2_hmac("sha256", password.encode(), salt, 600_000, dklen=32)
    return derived, salt


# ── Symmetric Encryption / AES (algorithm + related-crypto-material) ──

def encrypt_aes_gcm(plaintext: bytes, key: bytes) -> tuple:
    """algorithm: AES-256-GCM — quantum-safe authenticated encryption.
       related-crypto-material: nonce (auto-generated by PyCryptodome)."""
    cipher = AES.new(key, AES.MODE_GCM)
    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    return cipher.nonce, ciphertext, tag


def decrypt_aes_gcm(nonce: bytes, ciphertext: bytes, tag: bytes, key: bytes) -> bytes:
    """Decrypt AES-256-GCM with authentication verification."""
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    return cipher.decrypt_and_verify(ciphertext, tag)


def encrypt_aes_cbc(plaintext: bytes, key: bytes) -> tuple:
    """WARNING: AES-CBC has no authentication — use AES-GCM instead.
       related-crypto-material: IV (random 128-bit)."""
    iv = os.urandom(16)  # related-crypto-material: initialization vector
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)
    # Manual PKCS7 padding
    pad_len = 16 - (len(plaintext) % 16)
    padded = plaintext + bytes([pad_len] * pad_len)
    return iv, cipher.encrypt(padded)


# ── RSA Key Generation (algorithm + private-key) ────────────────

def generate_rsa_keypair_cryptography(key_size: int = 2048):
    """WARNING: RSA-2048 is NOT quantum-safe — migrate to ML-KEM.
       private-key: RSA private key object."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=key_size,
    )
    return private_key, private_key.public_key()


def generate_rsa_keypair_pycrypto(key_size: int = 4096):
    """WARNING: RSA-4096 — larger key but still NOT quantum-safe."""
    key = RSA.generate(key_size)
    return key, key.publickey()


# ── RSA Encryption (algorithm) ──────────────────────────────────

def encrypt_rsa_oaep(plaintext: bytes, public_key) -> bytes:
    """algorithm: RSA-OAEP — NOT quantum-safe."""
    return public_key.encrypt(
        plaintext,
        asym_padding.OAEP(
            mgf=asym_padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None,
        ),
    )


# ── Elliptic Curve / ECDSA (algorithm + private-key) ────────────

def generate_ec_keypair():
    """WARNING: ECDSA P-256 is NOT quantum-safe — migrate to ML-DSA.
       private-key: EC private key."""
    private_key = ec.generate_private_key(ec.SECP256R1())
    return private_key, private_key.public_key()


def sign_ecdsa(data: bytes, private_key) -> bytes:
    """algorithm: ECDSA with SHA-256 — NOT quantum-safe."""
    return private_key.sign(data, ec.ECDSA(hashes.SHA256()))


def verify_ecdsa(data: bytes, signature: bytes, public_key) -> bool:
    """Verify ECDSA signature."""
    try:
        public_key.verify(signature, data, ec.ECDSA(hashes.SHA256()))
        return True
    except Exception:
        return False


# ── Private Key Serialization (private-key) ─────────────────────

def export_private_key_pem(private_key) -> bytes:
    """private-key: Export RSA/EC private key in PKCS8 PEM format."""
    return private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption(),
    )


def export_private_key_encrypted(private_key, passphrase: bytes) -> bytes:
    """private-key: Export encrypted private key (password-protected)."""
    return private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.BestAvailableEncryption(passphrase),
    )


def export_public_key_pem(public_key) -> bytes:
    """Export public key in SubjectPublicKeyInfo PEM format."""
    return public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )


# ── Secret Key Construction (secret-key) ────────────────────────

def build_aes_key_from_shared_secret(shared_secret: bytes) -> bytes:
    """secret-key: Derive a 256-bit AES key from a shared secret via SHA-256."""
    return hashlib.sha256(shared_secret).digest()


# ── TLS / SSL Configuration (protocol) ──────────────────────────

def create_tls_client_context(certfile: str = None, keyfile: str = None) -> ssl.SSLContext:
    """protocol: TLS 1.2+ — symmetric ciphers quantum-safe,
       but ECDHE/RSA key exchange is NOT quantum-safe."""
    ctx = ssl.create_default_context()
    ctx.minimum_version = ssl.TLSVersion.TLSv1_2
    if certfile and keyfile:
        ctx.load_cert_chain(certfile=certfile, keyfile=keyfile)
    return ctx


def create_tls_server_context(certfile: str, keyfile: str) -> ssl.SSLContext:
    """protocol: TLS server context with certificate."""
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    ctx.minimum_version = ssl.TLSVersion.TLSv1_2
    ctx.load_cert_chain(certfile=certfile, keyfile=keyfile)
    return ctx


# ── Certificate Operations (certificate) ────────────────────────

def load_x509_certificate(pem_data: bytes):
    """certificate: Load and parse X.509 PEM certificate."""
    return load_pem_x509_certificate(pem_data)


def verify_certificate_signature(cert, issuer_public_key) -> bool:
    """certificate: Verify X.509 certificate signature with issuer key."""
    try:
        issuer_public_key.verify(
            cert.signature,
            cert.tbs_certificate_bytes,
            asym_padding.PKCS1v15(),
            cert.signature_hash_algorithm,
        )
        return True
    except Exception:
        return False


def get_certificate_info(cert) -> dict:
    """certificate: Extract metadata from X.509 certificate."""
    return {
        "subject": str(cert.subject),
        "issuer": str(cert.issuer),
        "serial_number": cert.serial_number,
        "not_valid_before": str(cert.not_valid_before_utc),
        "not_valid_after": str(cert.not_valid_after_utc),
        "signature_algorithm": cert.signature_algorithm_oid.dotted_string,
    }


# ── Related Crypto Material (related-crypto-material) ───────────

def generate_salt(length: int = 16) -> bytes:
    """related-crypto-material: Cryptographically secure random salt."""
    return os.urandom(length)


def generate_iv(length: int = 16) -> bytes:
    """related-crypto-material: Random initialization vector."""
    return os.urandom(length)


def generate_nonce(length: int = 12) -> bytes:
    """related-crypto-material: Random nonce for GCM/CTR modes."""
    return os.urandom(length)


# ── Full Workflow Example ────────────────────────────────────────

def secure_message_exchange(message: str):
    """Demo: Full encrypt → sign → MAC workflow covering all asset types."""
    # Generate keys (private-key + algorithm)
    rsa_priv, rsa_pub = generate_rsa_keypair_cryptography(4096)
    ec_priv, ec_pub = generate_ec_keypair()

    # Derive AES key from password (algorithm + related-crypto-material)
    aes_key, salt = derive_key_pbkdf2("demo-passphrase")

    # Hash the message (algorithm)
    msg_hash = hash_sha256(message.encode())

    # Encrypt with AES-GCM (algorithm + related-crypto-material)
    nonce, ciphertext, tag = encrypt_aes_gcm(message.encode(), aes_key)

    # Sign with ECDSA (algorithm)
    signature = sign_ecdsa(ciphertext, ec_priv)

    # Compute HMAC (algorithm)
    mac = compute_hmac_sha256(aes_key, ciphertext)

    # Export private key (private-key)
    priv_pem = export_private_key_pem(rsa_priv)

    return {
        "hash": msg_hash,
        "salt": salt.hex(),
        "nonce": nonce.hex(),
        "ciphertext": ciphertext.hex(),
        "tag": tag.hex(),
        "signature": signature.hex(),
        "mac": mac,
        "private_key_length": len(priv_pem),
    }


if __name__ == "__main__":
    result = secure_message_exchange("Hello, quantum-safe world!")
    print("Secure message exchange result:")
    for k, v in result.items():
        print(f"  {k}: {str(v)[:64]}...")
